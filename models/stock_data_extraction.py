"""
Stock Data Extraction Module

This module provides functionality to extract and process stock data from Yahoo Finance
with additional features for time series forecasting.
"""

import yfinance as yf
import pandas as pd
from pathlib import Path
from typing import Optional


def run_stock_data_extraction(ticker: str, output_csv: Optional[str] = None) -> pd.DataFrame:
    """
    Extract and process stock data from Yahoo Finance.
    
    Args:
        ticker (str): Stock ticker symbol (e.g., 'TSLA')
        output_csv (Optional[str]): Path to save the processed data as CSV
        
    Returns:
        pd.DataFrame: Processed stock data with additional features
    """
    # Download historical stock data from Yahoo Finance
    stock = yf.Ticker(ticker)
    
    # Get historical data - using all available columns first, then select what we need
    df = stock.history(period='max')
    df = df[["Open", "High", "Low", "Close", "Volume"]].copy()
    df.reset_index(inplace=True)  # Make 'Date' a column instead of index
    
    # Ensure Date column is in datetime format
    df["Date"] = pd.to_datetime(df["Date"])
    
    # Add earnings-related features
    try:
        earnings_dates = stock.earnings_dates.reset_index()[["Earnings Date"]]
        earnings_dates.rename(columns={"Earnings Date": "Earnings_Date"}, inplace=True)
        earnings_dates["Earnings_Date"] = pd.to_datetime(earnings_dates["Earnings_Date"])
        
        # For each date, find the most recent earnings date before or equal to that date
        df["last_earnings_date"] = df["Date"].apply(
            lambda x: earnings_dates[earnings_dates["Earnings_Date"] <= x]["Earnings_Date"].max()
        )
        
        # Calculate number of days since last earnings call
        df["days_since_earning"] = (df["Date"] - df["last_earnings_date"]).dt.days
        df["days_since_earning"] = df["days_since_earning"].fillna(0)
    except Exception as e:
        print(f"Warning: Could not fetch earnings data: {e}")
        df["last_earnings_date"] = None
        df["days_since_earning"] = 0
    
    # Add categorical time-based features
    df["month"] = df["Date"].dt.month.astype(str).astype("category")         # Month (1~12)
    df["day_of_week"] = df["Date"].dt.dayofweek.astype(str).astype("category")  # Day of week (0=Mon)
    df["quarter"] = df["Date"].dt.quarter.astype(str).astype("category")     # Quarter (1~4)
    df["year"] = df["Date"].dt.year.astype(str).astype("category")           # Year (e.g., 2023)
    
    # Add real-valued time-based indicators
    df["is_month_end"] = df["Date"].dt.is_month_end.astype(int)              # 1 if end of month
    df["is_month_start"] = df["Date"].dt.is_month_start.astype(int)          # 1 if start of month
    
    # Compute daily return (percentage change)
    df["return_1d"] = df["Close"].pct_change()
    
    # Compute rolling volatility (14-day standard deviation of returns)
    df["rolling_volatility"] = df["return_1d"].rolling(window=14, min_periods=1).std()
    
    # Compute cumulative return over time
    df["cumulative_return"] = (1 + df["return_1d"]).cumprod()
    
    # Drop rows with NaNs generated by rolling and pct_change
    df = df.dropna().reset_index(drop=True)
    
    # Generate time index starting from 0 (for TFT model)
    df["time_idx"] = range(len(df))
    
    # Add group id (required by TFT for multi-time-series handling)
    df["unique_id"] = ticker
    
    # Convert Date to string format for consistency
    df["Date"] = df["Date"].dt.strftime('%Y-%m-%d')
    
    # Save to CSV if path is provided
    if output_csv:
        df.to_csv(output_csv, index=False)
        print(f"Data saved to {output_csv}")
    
    return df


if __name__ == "__main__":
    # Example usage
    ticker = 'TSLA'
    # Save to data/interim folder
    output_path = Path(__file__).parent.parent / "data" / "interim" / f"{ticker}_price_full.csv"
    df = run_stock_data_extraction(ticker=ticker, output_csv=str(output_path))
    print(f"Extracted {len(df)} rows of data for {ticker}")
    print(df.head())
